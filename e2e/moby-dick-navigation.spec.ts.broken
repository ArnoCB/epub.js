import { test, expect } from '@playwright/test';

// Test configurations for different EPUB sources and layouts
const testConfigurations = [
  // Moby Dick - Web URL Unzipped (Package.opf)
  {
    name: 'Moby Dick (Web/Unzipped) - Auto Spread',
    url: 'https://s3.amazonaws.com/moby-dick/OPS/package.opf',
    source: 'web-unzipped',
    book: 'moby-dick',
    renditionConfig: {
      width: '100%',
      height: 600,
      spread: 'auto'
    },
    flow: 'paginated',
    testType: 'multi-source',
    description: 'Web-hosted unzipped EPUB with automatic spread detection'
  },
  {
    name: 'Moby Dick (Web/Unzipped) - Always Spread', 
    url: 'https://s3.amazonaws.com/moby-dick/OPS/package.opf',
    source: 'web-unzipped',
    book: 'moby-dick',
    renditionConfig: {
      width: '100%',
      height: 600,
      spread: 'always'
    },
    flow: 'paginated',
    testType: 'multi-source',
    description: 'Web-hosted unzipped EPUB with forced spread mode'
  },
  {
    name: 'Moby Dick (Web/Unzipped) - No Spread',
    url: 'https://s3.amazonaws.com/moby-dick/OPS/package.opf',
    source: 'web-unzipped', 
    book: 'moby-dick',
    renditionConfig: {
      width: '100%',
      height: 600,
      spread: 'none'
    },
    flow: 'paginated',
    testType: 'multi-source',
    description: 'Web-hosted unzipped EPUB in single-page mode'
  },

  // Moby Dick - Web URL Zipped (Full EPUB)
  {
    name: 'Moby Dick (Web/Zipped) - Auto Spread',
    url: 'https://s3.amazonaws.com/moby-dick/moby-dick.epub',
    source: 'web-zipped',
    book: 'moby-dick',
    renditionConfig: {
      width: '100%',
      height: 600,
      spread: 'auto'
    },
    flow: 'paginated',
    testType: 'multi-source',
    description: 'Web-hosted zipped EPUB with automatic spread detection'
  },

  // Alice in Wonderland - Web URL Unzipped
  {
    name: 'Alice (Web/Unzipped) - Auto Spread',
    url: 'https://s3.amazonaws.com/epubjs/books/alice/OPS/package.opf',
    source: 'web-unzipped',
    book: 'alice',
    renditionConfig: {
      width: '100%',
      height: 600,
      spread: 'auto'
    },
    flow: 'paginated',
    testType: 'multi-source',
    description: 'Web-hosted Alice EPUB with automatic spread detection'
  },
  {
    name: 'Alice (Web/Unzipped) - No Spread',
    url: 'https://s3.amazonaws.com/epubjs/books/alice/OPS/package.opf',
    source: 'web-unzipped',
    book: 'alice',
    renditionConfig: {
      width: '100%',
      height: 600,
      spread: 'none'
    },
    flow: 'paginated',
    testType: 'multi-source',
    description: 'Web-hosted Alice EPUB in single-page mode'
  },
  {
    name: 'Alice in Wonderland - Scrolled Flow',
    url: 'https://s3.amazonaws.com/epubjs/books/alice/OPS/package.opf',
    renditionConfig: {
      flow: 'scrolled-doc',
      width: '100%',
      fullsize: true
    },
    flow: 'scrolled',
    testType: 'multi-source',
    description: 'Continuous scrolling flow navigation'
  },
  {
    name: 'Moby Dick (Legacy Debug Page) - Spread Mode',
    url: 'https://s3.amazonaws.com/moby-dick/OPS/package.opf',
    renditionConfig: {
      width: 900,
      height: 600,
      spread: 'auto'
    },
    flow: 'paginated',
    testType: 'legacy',
    description: 'Original debug page configuration for regression testing'
  }
];

test.describe('EPUB Navigation Tests - Comprehensive Test Suite', () => {
  // Shared helper functions for all test configurations
  const getChapterState = async (page: any) => {
    return await page.evaluate(() => {
      const rendition = (window as any).rendition;
      const manager = rendition?.manager;
      const container = manager?.container;
      const visible = manager?.visible();

      if (visible && visible.length > 0) {
        const view = visible[0];
        const textContent = view.contents?.document?.body?.textContent?.trim() || '';
        
        return {
          scrollLeft: container?.scrollLeft || 0,
          scrollWidth: container?.scrollWidth || 0,
          offsetWidth: container?.offsetWidth || 0,
          visibleViews: visible.length,
          chapter: view.section?.href || 'unknown',
          hasContent: textContent.length > 100,
          textLength: textContent.length,
          preview: textContent.substring(0, 100) + '...',
          flow: rendition.settings?.flow || 'unknown',
          spread: rendition.settings?.spread || 'none'
        };
      }
      
      return { 
        scrollLeft: 0, 
        scrollWidth: 0, 
        offsetWidth: 0,
        visibleViews: 0,
        chapter: 'none', 
        hasContent: false, 
        textLength: 0, 
        preview: '',
        flow: 'unknown',
        spread: 'none'
      };
    });
  };

  const navigateNext = async (page: any, description = '') => {
    await page.evaluate(() => (window as any).rendition.next());
    await page.waitForTimeout(800);
    if (description) console.log(description);
  };

  const navigatePrev = async (page: any, description = '') => {
    await page.evaluate(() => (window as any).rendition.prev());
    await page.waitForTimeout(1000);
    if (description) console.log(description);
  };

  const setupModernConfig = async (page: any, baseURL: string, config: any) => {
    await page.goto(`${baseURL}/e2e/fixtures/epub-test-page.html`);

    page.on('console', (msg: any) => {
      try {
        console.log('PAGE:', msg.text());
      } catch {
        // ignore
      }
    });

    await page.waitForFunction(
      () => (window as any).ePub && typeof (window as any).ePub === 'function',
      { timeout: 15000 }
    );

    await page.evaluate(
      (testConfig) => {
        const book = (window as any).ePub(testConfig.url, {
          requestMethod: 'fetch',
          canonical: function(path: string) {
            return testConfig.url + '/../' + path;
          }
        });

        const rendition = book.renderTo('test-viewer', testConfig.renditionConfig);
        (window as any).book = book;
        (window as any).rendition = rendition;
        return rendition.display();
      },
      config
    );

    await page.waitForFunction(
      () => (window as any).rendition && typeof (window as any).rendition.next === 'function',
      { timeout: 15000 }
    );

    await page.waitForTimeout(3000);
  };

  const setupLegacyConfig = async (page: any, baseURL: string) => {
    await page.goto(`${baseURL}/debug-manual-browser.html`);

    page.on('console', (msg: any) => {
      try {
        console.log('PAGE:', msg.text());
      } catch {
        // ignore
      }
    });

    await page.waitForFunction(
      () => (window as any).ePub && typeof (window as any).ePub === 'function',
      { timeout: 15000 }
    );
    await page.waitForFunction(
      () => (window as any).rendition && typeof (window as any).rendition.next === 'function',
      { timeout: 15000 }
    );

    await page.evaluate(async () => {
      const r = (window as any).rendition;
      if (r && r.started) {
        try {
          await r.started;
        } catch (e) {}
      }
    });

    await page.waitForTimeout(2000);
  };

  const clickNext = async (page: any, description = '') => {
    await page.click('#next');
    await page.waitForTimeout(800);
    if (description) console.log(description);
  };

  const clickPrev = async (page: any, description = '') => {
    await page.click('#prev');
    await page.waitForTimeout(1000);
    if (description) console.log(description);
  };

  // Test each configuration
  for (const config of testConfigurations) {
    const setupPageWithConfig = async (page: any, baseURL: string) => {
      if (config.testType === 'legacy') {
        await setupLegacyConfig(page, baseURL);
      } else {
        await setupModernConfig(page, baseURL, config);
      }
    };

    test.describe(`Navigation tests for ${config.name}`, () => {
      test(`should handle basic navigation in ${config.name}`, async ({ page, baseURL }) => {
        test.setTimeout(60_000);
        await setupPageWithConfig(page, baseURL);

        console.log(`\n=== TESTING BASIC NAVIGATION: ${config.name} ===`);
        console.log(`Description: ${config.description}`);

        const initialState = await getChapterState();
        console.log('Initial state:', JSON.stringify(initialState, null, 2));

        // Ensure we have valid initial content
        expect(initialState.hasContent).toBe(true);
        expect(initialState.visibleViews).toBeGreaterThan(0);

        // Test forward navigation
        await clickNext(`ðŸ”„ Testing forward navigation in ${config.flow} flow`);
        const afterNext = await getChapterState();

        expect(afterNext.hasContent).toBe(true);
        expect(afterNext.visibleViews).toBeGreaterThan(0);
        console.log(`After next: ${afterNext.chapter}, content: ${afterNext.hasContent}`);

        // Test backward navigation
        await clickPrev(`ðŸ”„ Testing backward navigation in ${config.flow} flow`);
        const afterPrev = await getChapterState();

        expect(afterPrev.hasContent).toBe(true);
        expect(afterPrev.visibleViews).toBeGreaterThan(0);
        console.log(`After prev: ${afterPrev.chapter}, content: ${afterPrev.hasContent}`);

        console.log(`âœ… Basic navigation test completed for ${config.name}`);
      });

      if (config.flow === 'paginated') {
        test(`should prevent white pages during navigation in ${config.name}`, async ({ page, baseURL }) => {
          test.setTimeout(90_000);
          await setupPageWithConfig(page, baseURL);

          console.log(`\n=== TESTING WHITE PAGE PREVENTION: ${config.name} ===`);
          console.log(`Spread mode: ${config.renditionConfig.spread}`);

          let whitePageDetected = false;
          let stepCount = 0;
          const maxSteps = 20;

          // Navigate through multiple pages checking for white pages
          while (stepCount < maxSteps) {
            stepCount++;
            
            await clickNext(`ðŸ”„ Navigation step ${stepCount}`);
            
            const state = await getChapterState();
            console.log(`Step ${stepCount}: Chapter ${state.chapter}, Content: ${state.hasContent}, TextLength: ${state.textLength}`);
            
            // Check for white pages
            if (!state.hasContent || state.textLength < 50) {
              console.error(`âŒ WHITE PAGE DETECTED at step ${stepCount}`);
              console.error(`Chapter: ${state.chapter}`);
              console.error(`Text length: ${state.textLength}`);
              console.error(`Scroll: ${state.scrollLeft}/${state.scrollWidth}`);
              whitePageDetected = true;
              break;
            }
          }

          expect(whitePageDetected).toBe(false);
          console.log(`âœ… No white pages detected in ${config.name}`);
        });

        test(`should handle cross-chapter navigation in ${config.name}`, async ({ page, baseURL }) => {
          test.setTimeout(90_000);
          await setupPageWithConfig(page, baseURL);

          console.log(`\n=== TESTING CROSS-CHAPTER NAVIGATION: ${config.name} ===`);

          let currentChapter = (await getChapterState()).chapter;
          let stepCount = 0;
          const maxSteps = 15;

          console.log(`Starting from chapter: ${currentChapter}`);

          // Navigate forward until we reach a new chapter
          while (stepCount < maxSteps) {
            stepCount++;
            
            await clickNext(`ðŸ”„ Forward step ${stepCount}`);
            
            const state = await getChapterState();
            console.log(`Step ${stepCount} - Chapter: ${state.chapter}, hasContent: ${state.hasContent}`);
            
            // Ensure no white pages during navigation
            expect(state.hasContent).toBe(true);
            expect(state.visibleViews).toBeGreaterThan(0);
            
            // Check if we've moved to a new chapter
            if (state.chapter !== currentChapter) {
              console.log(`ðŸŽ¯ CHAPTER CHANGE DETECTED: ${currentChapter} â†’ ${state.chapter}`);
              
              // Test backward navigation across chapter boundary
              await clickPrev('ðŸ”„ Testing backward across chapter boundary');
              const afterBackward = await getChapterState();
              
              console.log(`After backward: ${afterBackward.chapter}, content: ${afterBackward.hasContent}`);
              expect(afterBackward.hasContent).toBe(true);
              expect(afterBackward.visibleViews).toBeGreaterThan(0);
              
              break;
            }
          }

          console.log(`âœ… Cross-chapter navigation test completed for ${config.name}`);
        });
      }

      if (config.flow === 'scrolled') {
        test(`should handle scrolled navigation in ${config.name}`, async ({ page, baseURL }) => {
          test.setTimeout(60_000);
          await setupPageWithConfig(page, baseURL);

          console.log(`\n=== TESTING SCROLLED FLOW NAVIGATION: ${config.name} ===`);

          const initialState = await getChapterState();
          expect(initialState.hasContent).toBe(true);

          // In scrolled flow, navigation works differently
          // Test that navigation methods exist and work
          for (let i = 1; i <= 5; i++) {
            await clickNext(`ðŸ”„ Scrolled next ${i}`);
            const state = await getChapterState();
            
            expect(state.hasContent).toBe(true);
            console.log(`Scrolled step ${i}: ${state.chapter}, content: ${state.hasContent}`);
          }

          // Test backward navigation
          for (let i = 1; i <= 3; i++) {
            await clickPrev(`ðŸ”„ Scrolled prev ${i}`);
            const state = await getChapterState();
            
            expect(state.hasContent).toBe(true);
            console.log(`Scrolled back ${i}: ${state.chapter}, content: ${state.hasContent}`);
          }

          console.log(`âœ… Scrolled navigation test completed for ${config.name}`);
        });
      }
    });
  });

  // Comparative test across configurations
  test('should maintain consistent navigation behavior across different EPUB sources and layouts', async ({ page, baseURL }) => {
    test.setTimeout(180_000);
    
    console.log('\n=== COMPARATIVE NAVIGATION TEST ACROSS CONFIGURATIONS ===');

    const results: any[] = [];

    // Test basic navigation for each configuration
    for (const config of testConfigurations.filter(c => c.flow === 'paginated')) {
      console.log(`\n--- Testing ${config.name} ---`);

      // Setup for this configuration
      await page.goto(`${baseURL}/e2e/fixtures/epub-test-page.html`);

      await page.waitForFunction(
        () => (window as any).ePub && typeof (window as any).ePub === 'function',
        { timeout: 15000 }
      );

      await page.evaluate(
        (testConfig) => {
          const book = (window as any).ePub(testConfig.url);
          const rendition = book.renderTo('test-viewer', testConfig.renditionConfig);
          (window as any).book = book;
          (window as any).rendition = rendition;
          return rendition.display();
        },
        config
      );

      await page.waitForFunction(
        () => (window as any).rendition && typeof (window as any).rendition.next === 'function',
        { timeout: 15000 }
      );

      await page.waitForTimeout(2000);

      // Test basic navigation
      const initialState = await page.evaluate(() => {
        const manager = (window as any).rendition?.manager;
        const visible = manager?.visible();
        if (visible && visible.length > 0) {
          const view = visible[0];
          const textContent = view.contents?.document?.body?.textContent?.trim() || '';
          return {
            chapter: view.section?.href || 'unknown',
            hasContent: textContent.length > 100,
            textLength: textContent.length
          };
        }
        return { chapter: 'none', hasContent: false, textLength: 0 };
      });

      // Navigate forward once
      await page.evaluate(() => (window as any).rendition.next());
      await page.waitForTimeout(1000);

      const afterNext = await page.evaluate(() => {
        const manager = (window as any).rendition?.manager;
        const visible = manager?.visible();
        if (visible && visible.length > 0) {
          const view = visible[0];
          const textContent = view.contents?.document?.body?.textContent?.trim() || '';
          return {
            chapter: view.section?.href || 'unknown',
            hasContent: textContent.length > 100,
            textLength: textContent.length
          };
        }
        return { chapter: 'none', hasContent: false, textLength: 0 };
      });

      results.push({
        config: config.name,
        initialState,
        afterNext,
        navigationWorked: initialState.hasContent && afterNext.hasContent
      });

      console.log(`${config.name}: Initial content: ${initialState.hasContent}, After next: ${afterNext.hasContent}`);
    }

    // Verify all configurations have working navigation
    const allWorking = results.every(r => r.navigationWorked);
    expect(allWorking).toBe(true);

    console.log('\n=== COMPARATIVE TEST RESULTS ===');
    results.forEach(result => {
      console.log(`${result.config}: Navigation ${result.navigationWorked ? 'PASSED' : 'FAILED'}`);
    });

    console.log('\nâœ… All EPUB sources and layouts maintain consistent navigation behavior');
  });
});

test.describe('Legacy Navigation Tests (Moby Dick Specific)', () => {
  let page: any;
  let baseURL: string;

  // Legacy setup using debug-manual-browser.html (for compatibility with existing tests)
  const setupLegacyPage = async (testPage: any, testBaseURL?: string) => {
    page = testPage;
    baseURL = testBaseURL || '';

    // Navigate to manual example
    await page.goto(`${baseURL}/debug-manual-browser.html`);

    // Add console logging
    page.on('console', (msg: any) => {
      try {
        console.log('PAGE:', msg.text());
      } catch {
        // ignore
      }
    });

    // Wait for library and rendition
    await page.waitForFunction(
      () => (window as any).ePub && typeof (window as any).ePub === 'function',
      { timeout: 15000 }
    );
    await page.waitForFunction(
      () =>
        (window as any).rendition &&
        typeof (window as any).rendition.next === 'function',
      { timeout: 15000 }
    );

    // Wait for rendition.started
    await page.evaluate(async () => {
      const r = (window as any).rendition;
      if (r && r.started) {
        try {
          await r.started;
        } catch (e) {}
      }
    });

    // Wait for initial load
    await page.waitForTimeout(2000);
  };

  // Helper function to get current chapter and content state
  const getChapterState = async () => {
    return await page.evaluate(() => {
      const manager = (window as any).rendition?.manager;
      const container = manager?.container;
      const visible = manager?.visible();

      if (visible && visible.length > 0) {
        const view = visible[0];
        const textContent = view.contents?.document?.body?.textContent?.trim() || '';
        
        return {
          scrollLeft: container?.scrollLeft || 0,
          scrollWidth: container?.scrollWidth || 0,
          offsetWidth: container?.offsetWidth || 0,
          visibleViews: visible.length,
          chapter: view.section?.href || 'unknown',
          hasContent: textContent.length > 500,
          textLength: textContent.length,
          preview: textContent.substring(0, 100) + '...',
        };
      }
      
      return { 
        scrollLeft: 0, 
        scrollWidth: 0, 
        offsetWidth: 0,
        visibleViews: 0,
        chapter: 'none', 
        hasContent: false, 
        textLength: 0, 
        preview: '' 
      };
    });
  };

  // Helper function to navigate forward
  const clickNext = async (description = '') => {
    await page.click('#next');
    await page.waitForTimeout(800); // Wait for navigation
    console.log(description);
  };

  // Helper function to navigate backward  
  const clickPrev = async (description = '') => {
    await page.click('#prev');
    await page.waitForTimeout(1000); // Wait for navigation
    console.log(description);
  };

  test('should handle spine item boundary navigation (legacy test)', async ({ page, baseURL }) => {
    test.setTimeout(60_000);
    await setupLegacyPage(page, baseURL);

    // Jump to a specific chapter to test cross-spine navigation
    await page.evaluate(() => {
      const rendition = (window as any).rendition;
      const book = (window as any).book;
      
      if (book && book.spine && book.spine.spineItems.length > 1) {
        console.log('Available spine items:', book.spine.spineItems.map((item: any) => item.href));
        // Navigate to the second spine item if available
        if (book.spine.spineItems[1]) {
          console.log('Jumping to second spine item:', book.spine.spineItems[1].href);
          return rendition.display(book.spine.spineItems[1].href);
        }
      }
      return Promise.resolve();
    });

    await page.waitForTimeout(2000);

    const stateAfterJump = await getChapterState();
    console.log('STATE AFTER JUMP:', JSON.stringify(stateAfterJump, null, 2));

    if (stateAfterJump.chapter === 'titlepage.xhtml') {
      // We're on titlepage, test navigation to previous spine item
      console.log('\n=== TESTING SPINE ITEM BOUNDARY NAVIGATION ===');
      
      await clickPrev('ðŸ”„ Testing spine boundary prev from titlepage');

      const stateAfterPrev = await getChapterState();
      console.log('STATE AFTER SPINE PREV:', JSON.stringify(stateAfterPrev, null, 2));

      // Note: titlepage might not have a valid previous spine item (cover might be non-navigable)
      // This test documents the current behavior rather than enforcing specific expectations
      console.log(`Navigation result: ${stateAfterJump.chapter} â†’ ${stateAfterPrev.chapter}`);
      
      // At minimum, ensure no crash and valid state
      expect(stateAfterPrev.chapter).toBeDefined();
      expect(stateAfterPrev.visibleViews).toBeGreaterThanOrEqual(0);
    } else {
      console.log('âš ï¸ Could not jump to titlepage, skipping spine boundary test');
    }
  });

  test('should maintain bidirectional navigation consistency (legacy)', async ({ page, baseURL }) => {
    test.setTimeout(90_000);
    await setupLegacyPage(page, baseURL);

    console.log('\n=== TESTING BIDIRECTIONAL NAVIGATION CONSISTENCY ===');

    // Get initial position
    const startState = await getChapterState();
    console.log(`Starting position: ${startState.chapter}, scroll: ${startState.scrollLeft}`);

    // Navigate forward several steps
    const forwardSteps = 5;
    for (let i = 1; i <= forwardSteps; i++) {
      await clickNext(`ðŸ”„ Forward step ${i}/${forwardSteps}`);
      const state = await getChapterState();
      expect(state.hasContent).toBe(true);
      console.log(`Forward ${i}: ${state.chapter}, scroll: ${state.scrollLeft}`);
    }

    const forwardEndState = await getChapterState();
    console.log(`After forward navigation: ${forwardEndState.chapter}, scroll: ${forwardEndState.scrollLeft}`);

    // Navigate backward the same number of steps
    for (let i = 1; i <= forwardSteps; i++) {
      await clickPrev(`ðŸ”„ Backward step ${i}/${forwardSteps}`);
      const state = await getChapterState();
      expect(state.hasContent).toBe(true);
      console.log(`Backward ${i}: ${state.chapter}, scroll: ${state.scrollLeft}`);
    }

    const backwardEndState = await getChapterState();
    console.log(`After backward navigation: ${backwardEndState.chapter}, scroll: ${backwardEndState.scrollLeft}`);

    // We should be close to where we started (allowing for some tolerance due to page boundaries)
    expect(backwardEndState.hasContent).toBe(true);
    expect(backwardEndState.visibleViews).toBeGreaterThan(0);
    
    // Test forward again to ensure navigation is still working
    await clickNext('ðŸ”„ Testing forward again after round trip');
    const finalState = await getChapterState();
    expect(finalState.hasContent).toBe(true);

    console.log('âœ… Bidirectional navigation consistency test completed successfully');
  });
});
