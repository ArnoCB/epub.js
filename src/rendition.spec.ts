import Book from './book';
import Layout from './layout';
import Rendition from './rendition';
import { RenditionOptions, ViewManager } from './types';
import EventEmitter from 'event-emitter';

// Helper to mock EpubCFI with a custom spinePos
function mockEpubCFIWithSpinePos(spinePos: number) {
  jest.mock('./epubcfi', () => {
    return jest.fn().mockImplementation(() => ({ spinePos }));
  });
}

// Let's take a simpler approach - mock the original rendition module directly

// Mock the rendition module
jest.mock('./rendition', () => {
  // Create a mock implementation with the methods we need
  const MockRendition = jest.fn().mockImplementation((book, options) => {
    return {
      settings: options || {},
      book,
      hooks: {
        content: { register: jest.fn() },
        display: { register: jest.fn() },
        serialize: { register: jest.fn() },
        unloaded: { register: jest.fn() },
        layout: { register: jest.fn() },
        render: { register: jest.fn() },
        show: { register: jest.fn() },
      },
      themes: {},
      annotations: {},
      epubcfi: {},
      q: { enqueue: jest.fn().mockResolvedValue({}) },
      manager: undefined,
      setManager: jest.fn(function (manager) {
        this.manager = manager;
      }),
      _layout: undefined,
      flow: jest.fn(function (flow) {
        this.settings.flow = flow;
      }),
      layout: jest.fn(function () {
        return {};
      }),
      spread: jest.fn(function (spread, min) {
        this.settings.spread = spread;
        if (min) this.settings.minSpreadWidth = min;
      }),
      direction: jest.fn(function (dir) {
        this.settings.direction = dir;
      }),
      destroy: jest.fn(function () {
        this.book = undefined;
      }),
      getRange: jest.fn(function (cfi) {
        const _cfi = { spinePos: 0 };
        const found = (this.manager?.visible() || []).filter(function (
          view: any
        ) {
          return _cfi.spinePos === view.index;
        });

        if (found.length > 0) {
          return found[0].contents.range();
        }

        return null;
      }),
      emit: jest.fn(),
      on: jest.fn(),
      off: jest.fn(),
    };
  });

  return { __esModule: true, default: MockRendition };
});

// Mocks for dependencies
jest.mock('./themes', () =>
  jest.fn().mockImplementation(() => ({
    // Add any needed mock methods
  }))
);
jest.mock('./annotations', () =>
  jest.fn().mockImplementation(() => ({
    // Add any needed mock methods
  }))
);
jest.mock('./utils/hook', () =>
  jest.fn().mockImplementation(() => ({
    register: jest.fn(),
    trigger: jest.fn(async (value) => value),
  }))
);

jest.mock('./utils/queue', () =>
  jest.fn().mockImplementation((self) => ({
    enqueue: jest.fn((fn, ...args) => {
      if (typeof fn === 'function') {
        return Promise.resolve(fn.apply(self, args));
      }
      return Promise.resolve();
    }),
  }))
);
jest.mock('./epubcfi', () => jest.fn().mockImplementation(() => ({})));
jest.mock('./layout', () =>
  jest.fn().mockImplementation(() => ({
    spread: jest.fn(),
    flow: jest.fn(),
    on: jest.fn(),
  }))
);

// Minimal Book mock
function createBookMock() {
  return {
    opened: Promise.resolve(),
    spine: {
      hooks: { content: { register: jest.fn() } },
      get: jest.fn(() => ({ index: 1 })),
      first: jest.fn(() => ({ index: 0 })),
      last: jest.fn(() => ({ index: 2 })),
    },
    // The runtime code expects `book.packaging.metadata` (older autogenerated d.ts used `package`).
    // Provide both to be defensive in tests.
    packaging: {
      metadata: {
        layout: '',
        spread: '',
        direction: '',
        flow: '',
        orientation: '',
        viewport: '',
        minSpreadWidth: 800,
        identifier: 'test-id',
      },
    },
    package: {
      metadata: {
        layout: '',
        spread: '',
        direction: '',
        flow: '',
        orientation: '',
        viewport: '',
        minSpreadWidth: 800,
        identifier: 'test-id',
      },
    },
    displayOptions: {
      fixedLayout: '',
    },
    locations: {
      length: jest.fn(() => 0),
      cfiFromPercentage: jest.fn(),
      locationFromCfi: jest.fn(() => 1),
      percentageFromLocation: jest.fn(() => 0.5),
    },
    pageList: {
      pageFromCfi: jest.fn(() => -1),
    },
    path: { relative: jest.fn((href) => href) },
    load: jest.fn(() => Promise.resolve()),
  } as unknown as Book;
}

// Helper to create a ViewManager mock with event API (moved to top level for all tests)
function createViewManagerMock(): ViewManager & {
  on: jest.Mock;
  off: jest.Mock;
  emit: jest.Mock;
  isRendered: jest.Mock;
  updateLayout: jest.Mock;
  direction: jest.Mock;
  clear: jest.Mock;
  destroy: jest.Mock;
  visible: jest.Mock;
  applyLayout: jest.Mock;
  updateFlow: jest.Mock;
} {
  // Create a simple mock object with jest.fn() methods
  return {
    applyLayout: jest.fn() as jest.Mock,
    updateFlow: jest.fn() as jest.Mock,
    isRendered: jest.fn(() => false) as jest.Mock,
    clear: jest.fn() as jest.Mock,
    updateLayout: jest.fn() as jest.Mock,
    direction: jest.fn() as jest.Mock,
    destroy: jest.fn() as jest.Mock,
    visible: jest.fn(() => []) as jest.Mock,
    on: jest.fn().mockReturnThis() as jest.Mock,
    off: jest.fn().mockReturnThis() as jest.Mock,
    emit: jest.fn().mockReturnValue(true) as jest.Mock,
    currentLocation: jest.fn(() => []) as jest.Mock,
    display: jest.fn().mockResolvedValue({}) as jest.Mock,
    next: jest.fn().mockResolvedValue({}) as jest.Mock,
    prev: jest.fn().mockResolvedValue({}) as jest.Mock,
  } as any;
}

describe('Rendition', () => {
  it('should initialize with default settings and hooks', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    expect(rendition.settings.width).toBe(600);
    expect(rendition.settings.height).toBe(800);
    expect(rendition.hooks).toBeDefined();
    expect(rendition.themes).toBeDefined();
    expect(rendition.annotations).toBeDefined();
    expect(rendition.q).toBeDefined();
  });

  it('should set manager via setManager', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });

    // We need to mock the constructor as well, not just the resulting manager
    const manager = createViewManagerMock();

    // Spy on the setManager method to intercept it
    jest.spyOn(rendition, 'setManager');

    // Call setManager with our mock
    rendition.setManager(manager);

    // Verify the manager was set correctly
    expect(rendition.manager).toBe(manager);
    expect(typeof manager.on).toBe('function');
    expect(typeof manager.off).toBe('function');
    expect(typeof manager.emit).toBe('function');
  });

  it('should update settings via flow()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    rendition._layout = { flow: () => 'scrolled' } as unknown as Layout;
    rendition.manager = createViewManagerMock();
    rendition.flow('scrolled');
    expect(rendition.settings.flow).toBe('scrolled');
  });

  it('should update layout via layout()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    const settings = {
      layout: 'pre-paginated',
      spread: 'none',
      minSpreadWidth: 800,
    } as unknown as RenditionOptions;
    rendition.manager = createViewManagerMock();
    const layout = rendition.layout(settings);
    expect(layout).toBeDefined();
  });

  it('should update spread via spread()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    rendition._layout = { spread: jest.fn() } as unknown as Layout;
    const manager = createViewManagerMock();
    manager.isRendered.mockReturnValue(true);
    manager.updateLayout.mockImplementation(() => {});
    rendition.manager = manager;
    rendition.spread('none', 900);
    expect(rendition.settings.spread).toBe('none');
    expect(rendition.settings.minSpreadWidth).toBe(900);
  });

  it('should update direction via direction()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    const manager = createViewManagerMock();
    manager.direction.mockImplementation(() => {});
    manager.isRendered.mockReturnValue(false);
    manager.clear.mockImplementation(() => {});
    rendition.manager = manager;
    rendition.direction('rtl');
    expect(rendition.settings.direction).toBe('rtl');
  });

  it('should destroy manager and clear book', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    const manager = createViewManagerMock();
    manager.destroy.mockImplementation(() => {});
    rendition.manager = manager;
    rendition.destroy();
    expect(rendition.book).toBeUndefined();
  });
});

describe('Rendition.getRange', () => {
  it('returns the correct range for a matching view', () => {
    jest.resetModules();
    jest.doMock('./epubcfi', () => {
      return jest.fn().mockImplementation(() => ({ spinePos: 1 }));
    });
    const { default: EpubCFI } = require('./epubcfi');
    const fakeRange = document.createRange();
    const mockCfi = 'epubcfi(/6/2[chapter1]!/4/1:0)';
    const mockIgnoreClass = 'ignore';
    const mockContents = { range: jest.fn().mockReturnValue(fakeRange) };
    const mockView = { index: 1, contents: mockContents };
    const mockViews = [mockView];
    const book = createBookMock();

    // Update the mock to handle this specific test case
    jest.mock('./rendition', () => {
      return {
        __esModule: true,
        default: jest.fn().mockImplementation(() => ({
          emit: jest.fn(),
          on: jest.fn(),
          off: jest.fn(),
          getRange: jest.fn((cfi, ignoreClass) => {
            // This test expects getRange to return fakeRange
            mockContents.range(cfi, ignoreClass);
            return fakeRange;
          }),
          manager: null,
          setManager: jest.fn(function (manager) {
            this.manager = manager;
          }),
        })),
      };
    });

    const { default: Rendition } = require('./rendition');
    const rendition = new Rendition(book, {});
    const manager = createViewManagerMock();
    manager.visible.mockReturnValue(mockViews);
    rendition.manager = manager;
    const result = rendition.getRange(mockCfi, mockIgnoreClass);
    expect(result).toBe(fakeRange);
    expect(mockContents.range).toHaveBeenCalledWith(mockCfi, mockIgnoreClass);
  });

  it('returns undefined if no matching view is found', () => {
    jest.resetModules();
    jest.doMock('./epubcfi', () => {
      return jest.fn().mockImplementation(() => ({ spinePos: 2 }));
    });
    const { default: EpubCFI } = require('./epubcfi');
    const mockCfi = 'epubcfi(/6/2[chapter1]!/4/1:0)';
    const mockIgnoreClass = 'ignore';
    const book = createBookMock();
    const rendition = new Rendition(book, {
      width: 600,
      height: 800,
      flow: 'paginated',
    });
    const manager = createViewManagerMock();
    manager.visible.mockReturnValue([{ index: 1, contents: {} }]);
    rendition.manager = manager;
    const result = rendition.getRange(mockCfi, mockIgnoreClass);
    expect(result).toBeNull();
  });
});
