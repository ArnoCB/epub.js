import Book from './book';
import Layout from './layout';
import Rendition from './rendition';
import { RenditionOptions, ViewManager } from './types';

// Helper to mock EpubCFI with a custom spinePos
function mockEpubCFIWithSpinePos(spinePos: number) {
  jest.mock('./epubcfi', () => {
    return jest.fn().mockImplementation(() => ({ spinePos }));
  });
}

// Mocks for dependencies
jest.mock('./themes', () =>
  jest.fn().mockImplementation(() => ({
    // Add any needed mock methods
  }))
);
jest.mock('./annotations', () =>
  jest.fn().mockImplementation(() => ({
    // Add any needed mock methods
  }))
);
jest.mock('./utils/hook', () =>
  jest.fn().mockImplementation(() => ({
    register: jest.fn(),
    trigger: jest.fn(async (value) => value),
  }))
);

jest.mock('./utils/queue', () =>
  jest.fn().mockImplementation((self) => ({
    enqueue: jest.fn((fn, ...args) => {
      if (typeof fn === 'function') {
        return Promise.resolve(fn.apply(self, args));
      }
      return Promise.resolve();
    }),
  }))
);
jest.mock('./epubcfi', () => jest.fn().mockImplementation(() => ({})));
jest.mock('./layout', () =>
  jest.fn().mockImplementation(() => ({
    spread: jest.fn(),
    flow: jest.fn(),
    on: jest.fn(),
  }))
);

// Minimal Book mock
function createBookMock() {
  return {
    opened: Promise.resolve(),
    spine: {
      hooks: { content: { register: jest.fn() } },
      get: jest.fn(() => ({ index: 1 })),
      first: jest.fn(() => ({ index: 0 })),
      last: jest.fn(() => ({ index: 2 })),
    },
    // The runtime code expects `book.packaging.metadata` (older autogenerated d.ts used `package`).
    // Provide both to be defensive in tests.
    packaging: {
      metadata: {
        layout: '',
        spread: '',
        direction: '',
        flow: '',
        orientation: '',
        viewport: '',
        minSpreadWidth: 800,
        identifier: 'test-id',
      },
    },
    package: {
      metadata: {
        layout: '',
        spread: '',
        direction: '',
        flow: '',
        orientation: '',
        viewport: '',
        minSpreadWidth: 800,
        identifier: 'test-id',
      },
    },
    displayOptions: {
      fixedLayout: '',
    },
    locations: {
      length: jest.fn(() => 0),
      cfiFromPercentage: jest.fn(),
      locationFromCfi: jest.fn(() => 1),
      percentageFromLocation: jest.fn(() => 0.5),
    },
    pageList: {
      pageFromCfi: jest.fn(() => -1),
    },
    path: { relative: jest.fn((href) => href) },
    load: jest.fn(() => Promise.resolve()),
  } as unknown as Book;
}

describe('Rendition', () => {
  it('should initialize with default settings and hooks', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    expect(rendition.settings.width).toBe(600);
    expect(rendition.settings.height).toBe(800);
    expect(rendition.hooks).toBeDefined();
    expect(rendition.themes).toBeDefined();
    expect(rendition.annotations).toBeDefined();
    expect(rendition.q).toBeDefined();
  });

  it('should set manager via setManager', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    const manager = jest.fn() as unknown as ViewManager;
    rendition.setManager(manager);
    expect(rendition.manager).toBe(manager);
  });

  it('should update settings via flow()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    rendition._layout = { flow: () => 'scrolled' } as unknown as Layout;
    rendition.manager = {
      applyLayout: jest.fn(),
      updateFlow: jest.fn(),
      isRendered: jest.fn(() => false),
      clear: jest.fn(),
      updateLayout: jest.fn(),
    } as unknown as ViewManager;
    rendition.flow('scrolled');
    expect(rendition.settings.flow).toBe('scrolled');
  });

  it('should update layout via layout()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    const settings = {
      layout: 'pre-paginated',
      spread: 'none',
      minSpreadWidth: 800,
    } as unknown as RenditionOptions;
    rendition.manager = { applyLayout: jest.fn() } as unknown as ViewManager;
    const layout = rendition.layout(settings);
    expect(layout).toBeDefined();
  });

  it('should update spread via spread()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    rendition._layout = { spread: jest.fn() } as unknown as Layout;
    rendition.manager = {
      updateLayout: jest.fn(),
      isRendered: jest.fn(() => true),
    } as unknown as ViewManager;
    rendition.spread('none', 900);
    expect(rendition.settings.spread).toBe('none');
    expect(rendition.settings.minSpreadWidth).toBe(900);
  });

  it('should update direction via direction()', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    rendition.manager = {
      direction: jest.fn(),
      isRendered: jest.fn(() => false),
      clear: jest.fn(),
    } as unknown as ViewManager;
    rendition.direction('rtl');
    expect(rendition.settings.direction).toBe('rtl');
  });

  it('should destroy manager and clear book', () => {
    const book = createBookMock();
    const rendition = new Rendition(book, { width: 600, height: 800 });
    rendition.manager = { destroy: jest.fn() } as unknown as ViewManager;
    rendition.destroy();
    expect(rendition.book).toBeUndefined();
  });

  // Add more tests for public methods as needed
});

describe('Rendition.getRange', () => {
  it('returns the correct range for a matching view', () => {
    jest.resetModules();
    jest.doMock('./epubcfi', () => {
      return jest.fn().mockImplementation(() => ({ spinePos: 1 }));
    });
    const { default: EpubCFI } = require('./epubcfi');
    const fakeRange = document.createRange();
    const mockCfi = 'epubcfi(/6/2[chapter1]!/4/1:0)';
    const mockIgnoreClass = 'ignore';
    const mockContents = { range: jest.fn().mockReturnValue(fakeRange) };
    const mockView = { index: 1, contents: mockContents };
    const mockViews = [mockView];
    const book = createBookMock();
    const { default: Rendition } = require('./rendition');
    const rendition = new Rendition(book, {});
    rendition.manager = { visible: () => mockViews } as any;
    const result = rendition.getRange(mockCfi, mockIgnoreClass);
    expect(result).toBe(fakeRange);
    expect(mockContents.range).toHaveBeenCalledWith(
      expect.any(Object),
      mockIgnoreClass
    );
  });

  it('returns undefined if no matching view is found', () => {
    jest.resetModules();
    jest.doMock('./epubcfi', () => {
      return jest.fn().mockImplementation(() => ({ spinePos: 2 }));
    });
    const { default: EpubCFI } = require('./epubcfi');
    const mockCfi = 'epubcfi(/6/2[chapter1]!/4/1:0)';
    const mockIgnoreClass = 'ignore';
    const book = createBookMock();
    const rendition = new Rendition(book, {});
    rendition.manager = { visible: () => [{ index: 1, contents: {} }] } as any;
    const result = rendition.getRange(mockCfi, mockIgnoreClass);
    expect(result).toBeUndefined();
  });
});
