<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>EPUB.js Pre-Rendering Example</title>

  <script src="../dist/epub.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>

  <link rel="stylesheet" type="text/css" href="examples.css">

  <style type="text/css">
    /* Fix scrollbar issue */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    ::selection {
      background: yellow;
    }

    #extras {
      width: 800px;
      margin: 40px auto;
    }

    #debug-panel {
      background: #f5f5f5;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 15px;
      margin-bottom: 20px;
      font-family: monospace;
      font-size: 12px;
    }

    #debug-panel h3 {
      margin-top: 0;
      color: #333;
      font-family: Arial, sans-serif;
    }

    #debug-info {
      background: white;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 3px;
      max-height: 300px;
      overflow-y: auto;
    }

    #chapter-status {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    .chapter-card {
      background: white;
      border: 1px solid #ddd;
      border-radius: 3px;
      padding: 8px;
      font-size: 11px;
    }

    .chapter-card.rendered {
      border-color: #28a745;
      background-color: #d4edda;
    }

    .chapter-card.attached {
      border-color: #007bff;
      background-color: #cce5ff;
    }

    .chapter-card.failed {
      border-color: #dc3545;
      background-color: #f8d7da;
    }

    #status-bar {
      background: #007bff;
      color: white;
      padding: 10px;
      border-radius: 3px;
      margin-bottom: 15px;
      text-align: center;
    }

    #progress-bar {
      width: 100%;
      height: 20px;
      background: #e9ecef;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 8px;
    }

    #progress-fill {
      height: 100%;
      background: #28a745;
      width: 0%;
      transition: width 0.3s ease;
    }

    #controls {
      margin-bottom: 20px;
    }

    #controls button {
      margin-right: 10px;
      padding: 8px 16px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    #controls button:hover {
      background: #0056b3;
    }

    #controls button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }

    #viewer.spreads {
      top: 0;
      margin-top: 50px;
      background-color: transparent;
      overflow: hidden !important; /* Force hidden overflow */
    }

    .highlight {
      background: rgba(255, 255, 0, 0.3);
      cursor: pointer;
    }

    #highlights {
      list-style: none;
      margin-left: 0;
      padding: 0;
    }

    #highlights li {
      list-style: none;
      margin-bottom: 10px;
      border-top: 1px solid #E2E2E2;
      padding: 10px;
      background: white;
      border-radius: 3px;
    }

    #highlights a {
      display: inline-block;
      margin-right: 10px;
      color: #007bff;
      text-decoration: none;
    }

    #highlights a:hover {
      text-decoration: underline;
    }

    .log-entry {
      margin: 2px 0;
      padding: 2px 0;
      border-bottom: 1px solid #eee;
    }

    .log-entry.info {
      color: #007bff;
    }

    .log-entry.success {
      color: #28a745;
    }

    .log-entry.warning {
      color: #ffc107;
    }

    .log-entry.error {
      color: #dc3545;
    }
  </style>
</head>
<body>
  <div id="frame">
    <div id="viewer" class="spreads"></div>
    <a id="prev" href="#prev" class="arrow">‚Äπ</a>
    <a id="next" href="#next" class="arrow">‚Ä∫</a>
  </div>

  <div id="extras">
    <!-- Pre-rendering Status Panel -->
    <div id="debug-panel">
      <h3>üìö Pre-Rendering System Status</h3>
      
      <div id="status-bar">
        <div id="status-text">Initializing pre-rendering system...</div>
        <div id="progress-bar">
          <div id="progress-fill"></div>
        </div>
      </div>

      <div id="controls">
        <button id="toggle-prerendering">Toggle Pre-rendering</button>
        <button id="refresh-debug">Refresh Debug Info</button>
        <button id="jump-to-chapter">Jump to Chapter</button>
        <button id="clear-logs">Clear Logs</button>
      </div>

      <div id="chapter-status"></div>
      
      <details>
        <summary><strong>Debug Information</strong></summary>
        <div id="debug-info"></div>
      </details>

      <details>
        <summary><strong>System Logs</strong></summary>
        <div id="system-logs"></div>
      </details>
    </div>

    <!-- Highlights Section -->
    <div id="highlights-section">
      <h3>üìù Highlights</h3>
      <ul id="highlights"></ul>
    </div>
  </div>

  <script>
    let book, rendition;
    let preRenderingEnabled = true;
    let systemLogs = [];

    // Global getter functions for testing
    window.getRendition = () => rendition;
    window.getBook = () => book;
    window.getPreRenderer = () => rendition?.manager?.preRenderer;

    // Logging function
    function addLog(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      systemLogs.push({ timestamp, message, type });
      
      // Keep only last 100 logs
      if (systemLogs.length > 100) {
        systemLogs = systemLogs.slice(-100);
      }
      
      updateSystemLogs();
      // Console logging disabled to reduce test noise
    }

    function updateSystemLogs() {
      const logsContainer = document.getElementById('system-logs');
      logsContainer.innerHTML = systemLogs.map(log => 
        `<div class="log-entry ${log.type}">[${log.timestamp}] ${log.message}</div>`
      ).join('');
      logsContainer.scrollTop = logsContainer.scrollHeight;
    }

    // Helper: read a desired start target from the URL (e.g., ?start=chapter_001.xhtml or ?start=3)
    function getStartTargetFromUrl() {
      try {
        const params = new URLSearchParams(window.location.search);
        const raw = params.get('start') || params.get('href') || params.get('spine');
        if (!raw) return null;
        const trimmed = String(raw).trim();
        if (trimmed === '') return null;
        if (!isNaN(Number(trimmed))) {
          return parseInt(trimmed, 10);
        }
        return trimmed; // href or CFI
      } catch (e) {
        return null;
      }
    }

    // Initialize the book
    function initializeBook() {
      addLog("Loading EPUB book...", "info");
      
      book = window.ePub("https://s3.amazonaws.com/moby-dick/OPS/package.opf", {
        keepAbsoluteUrl: true
      });
      
      rendition = book.renderTo("viewer", {
        width: "100%",
        height: 600,
        ignoreClass: 'annotator-hl',
        manager: "default", // This should now work with usePreRendering
        flow: "paginated",
        spread: "auto", 
        transparency: true,
        allowScriptedContent: true, // Enable scripts for proper pre-rendered content display
        usePreRendering: preRenderingEnabled // üéâ Enable pre-rendering!
      });

      addLog(`Rendition created with usePreRendering: ${preRenderingEnabled}`, "info");

      setupEventListeners();
      
      // Don't display immediately - wait for pre-rendering to start in attached event
      addLog("Waiting for rendition to be attached before initial display", "info");
    }

    function setupEventListeners() {
      // Book and rendition events
      book.ready.then(() => {
        addLog(`Book loaded: ${book.packaging.metadata.title}`, "success");
        addLog(`Total sections: ${book.spine.length}`, "info");
      });

      rendition.on("started", function() {
        addLog("Rendition started", "success");
        addLog(`Layout: ${rendition.manager.layout.name}`, "info");
        
        // Apply custom styling now that rendition is started
        applyCustomStyling();
      });

      // Check pre-renderer after attachment is complete
      rendition.on("attached", function() {
        addLog("Rendition attached - checking pre-renderer...", "info");
        addLog(`Pre-rendering enabled: ${!!rendition.manager.preRenderer}`, "info");
        addLog(`Manager usePreRendering: ${rendition.manager.usePreRendering}`, "info");
        addLog(`Manager type: ${rendition.manager.constructor.name}`, "info");
        addLog(`Manager name: ${rendition.manager.name}`, "info");
        addLog(`Manager settings: ${JSON.stringify(rendition.manager.settings)}`, "info");
        
        // Start at spine index 1 (first linear chapter after cover)
        // Note: Cover pages often have linear:false and don't have proper navigation links
        addLog("Starting at spine index 1 (first chapter after cover)", "info");
        rendition.display(1);
        
        updateStatus();
        
        // Start pre-rendering immediately when attached and book is ready
        if (book.spine && rendition.manager && rendition.manager.preRenderer) {
          const sections = book.spine.spineItems;
          addLog(`Starting pre-rendering of ${sections.length} chapters immediately...`, "info");
          
          rendition.manager.startPreRendering(sections).then(() => {
            addLog("Pre-rendering completed successfully", "success");
            updateStatus();
          }).catch(err => {
            addLog(`Pre-rendering failed: ${err.message}`, "error");
          });
        } else {
          addLog("Book spine or pre-renderer not ready for immediate start", "warning");
        }
      });

      // Wait for book to be ready AND rendition to be attached before logging status
      Promise.all([book.ready, new Promise(resolve => rendition.on("attached", resolve))]).then(() => {
        addLog(`Book ready: ${book.packaging.metadata.title}`, "success");
        addLog(`Total sections: ${book.spine.length}`, "info");
        
        // Pre-rendering should start automatically when usePreRendering: true
        if (rendition.manager && rendition.manager.preRenderer) {
          addLog(`Pre-renderer is available and should auto-start`, "info");
        } else {
          addLog("Pre-renderer not available", "warning");
        }
        updateStatus();
      });

      rendition.on("rendered", function(section, view) {
        const sectionHref = section?.href || '(unknown section)';
        addLog(`Chapter rendered: ${sectionHref}`, "success");
        updateStatus();
      });

      rendition.on("relocated", function(location) {
        const href = location?.start?.href || '(unknown)';
        const pageInfo = location?.start?.displayed
          ? `page ${location.start.displayed.page} / ${location.start.displayed.total}`
          : '';
        // Expose last relocated location for automated tests to observe
        try {
          window.__lastRelocated = location;
        } catch (e) {
          // ignore in browsers that restrict assigning to window properties in strict contexts
        }
        addLog(`Navigated to href: ${href} ${pageInfo}`, "info");
        updateStatus();
      });

      // Pre-renderer specific events
      if (rendition.manager && rendition.manager.preRenderer) {
        rendition.manager.on("added", function(data) {
          // Handle different types of added events
          if (data && typeof data === 'object' && data.total && data.rendered) {
            // This is a pre-rendering status update
            addLog(`Pre-rendering progress: ${data.rendered}/${data.total} chapters`, "success");
          } else if (data && data.section) {
            // This is a view being added
            addLog(`Chapter view added: ${data.section.href}`, "info");
          }
          updateStatus();
        });
      }

      // Navigation
      document.getElementById("next").addEventListener("click", function(e) {
        e.preventDefault();
        addLog("Next button clicked", "info");
        rendition.next();
      });

      document.getElementById("prev").addEventListener("click", function(e) {
        e.preventDefault();
        addLog("Previous button clicked", "info");
        rendition.prev();
      });

      // Keyboard navigation
      document.addEventListener("keyup", function(e) {
        if (e.keyCode === 37) { // Left arrow
          addLog("Left arrow pressed", "info");
          rendition.prev();
        } else if (e.keyCode === 39) { // Right arrow
          addLog("Right arrow pressed", "info");
          rendition.next();
        }
      });

      // Text selection and highlighting
      rendition.on("selected", function(cfiRange, contents) {
        addLog(`Text selected: ${cfiRange}`, "info");
        
        // Add highlight
        rendition.annotations.highlight(cfiRange, {}, (e) => {
          addLog("Highlight clicked", "info");
        });
        
        contents.window.getSelection().removeAllRanges();
        addHighlightToList(cfiRange);
      });

      // Control buttons
      document.getElementById("toggle-prerendering").addEventListener("click", function() {
        preRenderingEnabled = !preRenderingEnabled;
        addLog(`Pre-rendering ${preRenderingEnabled ? 'enabled' : 'disabled'}`, "info");
        // Note: This would require reinitializing the rendition to take effect
        alert(`Pre-rendering ${preRenderingEnabled ? 'enabled' : 'disabled'}. Reload page to take effect.`);
      });

      document.getElementById("refresh-debug").addEventListener("click", function() {
        addLog("Refreshing debug information", "info");
        updateStatus();
      });

      document.getElementById("jump-to-chapter").addEventListener("click", function() {
        const input = prompt("Enter spine index (0-based) or href (e.g., chapter_001.xhtml):");
        if (input === null) return;

        // If numeric, treat as spine index
        if (!isNaN(Number(input))) {
          const chapterIndex = parseInt(input, 10);
          addLog(`Jumping to spine index ${chapterIndex}`, "info");
          rendition.display(chapterIndex);
          return;
        }

        // Otherwise, try to resolve href to a spine index then display
        const raw = String(input).trim();
        const href = raw.split('#')[0];
        const spine = book.spine;
        const section = spine.get(href);
        if (section) {
          addLog(`Jumping to href ${href} (index ${section.index})`, "info");
          rendition.display(href);
        } else {
          addLog(`Could not resolve href: ${href}`, "error");
        }
      });

      document.getElementById("clear-logs").addEventListener("click", function() {
        systemLogs = [];
        updateSystemLogs();
        addLog("Logs cleared", "info");
      });
    }

    function addHighlightToList(cfiRange) {
      book.getRange(cfiRange).then(function(range) {
        if (range) {
          const text = range.toString();
          const li = document.createElement('li');
          const a = document.createElement('a');
          const remove = document.createElement('a');
          const textSpan = document.createElement('span');

          a.textContent = `üìç ${cfiRange}`;
          a.href = "#" + cfiRange;
          a.onclick = function(e) {
            e.preventDefault();
            addLog(`Navigating to highlight: ${cfiRange}`, "info");
            rendition.display(cfiRange);
          };

          remove.textContent = "üóëÔ∏è Remove";
          remove.href = "#" + cfiRange;
          remove.onclick = function(e) {
            e.preventDefault();
            addLog(`Removing highlight: ${cfiRange}`, "info");
            rendition.annotations.remove(cfiRange);
            li.remove();
            return false;
          };

          textSpan.textContent = text;
          textSpan.style.fontStyle = 'italic';

          li.appendChild(a);
          li.appendChild(textSpan);
          li.appendChild(remove);
          document.getElementById('highlights').appendChild(li);
        }
      });
    }

    function updateStatus() {
      const statusText = document.getElementById('status-text');
      const progressFill = document.getElementById('progress-fill');
      const chapterStatus = document.getElementById('chapter-status');
      const debugInfo = document.getElementById('debug-info');

      if (!rendition || !rendition.manager) {
        statusText.textContent = "Rendition not ready";
        return;
      }

      const preRenderer = rendition.manager.preRenderer;
      
      if (preRenderer) {
        const status = preRenderer.getStatus();
        const percentage = status.total > 0 ? (status.rendered / status.total) * 100 : 0;
        
        statusText.innerHTML = `
          <strong>Pre-rendering Status:</strong> ${status.rendered}/${status.total} chapters rendered 
          (${status.failed} failed) - ${percentage.toFixed(1)}%
        `;
        progressFill.style.width = percentage + '%';

        // Update chapter status cards
        updateChapterStatusCards(preRenderer);
        
        // Update debug info
        const debugData = preRenderer.getDebugInfo();
        debugInfo.innerHTML = `<pre>${JSON.stringify(debugData, null, 2)}</pre>`;
      } else {
        statusText.innerHTML = "<strong>Pre-rendering:</strong> Disabled";
        progressFill.style.width = '0%';
        chapterStatus.innerHTML = '<div>Pre-rendering is disabled</div>';
        debugInfo.innerHTML = '<div>No pre-renderer available</div>';
      }
    }

    function updateChapterStatusCards(preRenderer) {
      const chapterStatus = document.getElementById('chapter-status');
      const chapters = preRenderer.getAllChapters();
      
      chapterStatus.innerHTML = chapters.map(chapter => {
        let statusClass = '';
        let statusText = 'Pending';
        
        if (chapter.attached) {
          statusClass = 'attached';
          statusText = 'Displayed';
        } else if (chapter.rendered.promise) {
          // Check if promise is resolved
          statusClass = 'rendered';
          statusText = 'Pre-rendered';
        }

        const fileName = chapter.section.href.split('/').pop();
        
        return `
          <div class="chapter-card ${statusClass}">
            <div><strong>${fileName}</strong></div>
            <div>Index: ${chapter.section.index}</div>
            <div>Status: ${statusText}</div>
            <div>Size: ${chapter.width}√ó${chapter.height}</div>
          </div>
        `;
      }).join('');
    }

    // Apply custom styling
    function applyCustomStyling() {
      if (rendition && rendition.themes && rendition.manager) {
        addLog("Applying custom styling to rendition", "info");
        try {
          rendition.themes.default({
            '::selection': {
              'background': 'rgba(255,255,0, 0.3)'
            },
            '.highlight': {
              'background': 'rgba(255,255,0, 0.3)',
              'cursor': 'pointer'
            }
          });
        } catch (e) {
          addLog("Failed to apply custom styling: " + e.message, "error");
        }
      } else {
        addLog("Skipping custom styling - rendition not ready", "warning");
      }
    }

    // Initialize everything when the page loads
    document.addEventListener('DOMContentLoaded', function() {
      addLog("Page loaded, initializing...", "info");
      initializeBook();
      // Don't apply styling immediately - wait for rendition to be ready
      
      // Update status every 2 seconds
      setInterval(updateStatus, 2000);
      
      // Add window resize debugging
      let resizeTimeout;
      window.addEventListener('resize', function() {
        addLog("Window resize detected", "info");
        
        // Clear any existing timeout
        clearTimeout(resizeTimeout);
        
        // Debounce the resize handling
        resizeTimeout = setTimeout(() => {
          addLog("Processing resize...", "info");
          
          if (rendition) {
            // Log current state before resize
            const beforeIframes = document.querySelectorAll('#viewer iframe').length;
            addLog(`Before resize: ${beforeIframes} iframes visible`, "info");
            
            // Trigger the resize
            rendition.resize();
            
            // Check state after resize
            setTimeout(() => {
              const afterIframes = document.querySelectorAll('#viewer iframe').length;
              addLog(`After resize: ${afterIframes} iframes visible`, "info");
              
              if (afterIframes === 0) {
                addLog("WARNING: All iframes disappeared after resize!", "error");
                
                // Try to get debug info from prerenderer
                const preRenderer = rendition.manager?.preRenderer;
                if (preRenderer) {
                  const debugInfo = preRenderer.getDebugInfo();
                  addLog(`PreRenderer debug: ${JSON.stringify(debugInfo)}`, "info");
                }
              }
            }, 100);
          }
        }, 250);
      });
    });

    // Expose some functions to global scope for debugging
    window.epubDebug = {
      addLog,
      updateStatus,
      getPreRenderer: () => rendition?.manager?.preRenderer,
      getDebugInfo: () => rendition?.manager?.preRenderer?.getDebugInfo(),
      book,
      rendition,
      triggerResize: () => {
        addLog("Manual resize triggered", "info");
        if (rendition) rendition.resize();
      }
    };

    addLog("Pre-rendering example initialized", "success");
  </script>

</body>
</html>
