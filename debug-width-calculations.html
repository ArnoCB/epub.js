<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Debug Width Calculations</title>
  <script src="dist/epub.umd.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .debug-info { background: #f0f0f0; padding: 10px; margin: 10px 0; border: 1px solid #ccc; }
    .error { background: #ffe6e6; border-color: #ff9999; }
    .success { background: #e6ffe6; border-color: #99ff99; }
  </style>
</head>
<body>
  <h1>Width Calculation Debug</h1>
  <button onclick="startDebug()">Start Debug</button>
  <div id="output"></div>
  <div id="viewer" style="width: 900px; height: 600px; overflow: hidden; position: relative; border: 2px solid #333; margin: 20px 0;"></div>

  <script>
    let book, rendition;
    
    function log(message, isError = false) {
      const output = document.getElementById('output');
      const div = document.createElement('div');
      div.className = `debug-info ${isError ? 'error' : 'success'}`;
      div.innerHTML = `<strong>${new Date().toLocaleTimeString()}:</strong> ${message}`;
      output.appendChild(div);
      console.log(message);
    }
    
    async function startDebug() {
      try {
        log("Loading book...");
        book = window.ePub("https://s3.amazonaws.com/moby-dick/OPS/package.opf", {
          keepAbsoluteUrl: true
        });

        await book.ready;
        log("Book loaded successfully");

        rendition = book.renderTo("viewer", {
          width: "100%",
          height: "600px",
          spread: "none",
          manager: "default"
        });

        // Get the problematic sections
        const sections = book.spine.spineItems;
        const problemSections = [
          sections.find(s => s.href.includes('cover')),
          sections.find(s => s.href.includes('titlepage')), 
          sections.find(s => s.href.includes('toc-short')),
          sections.find(s => s.href.includes('preface')),
          sections.find(s => s.href.includes('introduction')),
          sections.find(s => s.href.includes('epigraph')),
          sections.find(s => s.href.includes('chapter_001'))
        ].filter(Boolean);

        log(`Found ${problemSections.length} sections to test`);

        // Test each section individually
        for (let i = 0; i < problemSections.length; i++) {
          const section = problemSections[i];
          log(`<hr><h3>Testing Section ${i + 1}: ${section.href}</h3>`);
          
          try {
            await rendition.display(section.href);
            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait for render
            
            await debugSectionWidths(section);
            
          } catch (error) {
            log(`Error displaying section ${section.href}: ${error.message}`, true);
          }
        }
        
      } catch (error) {
        log(`Error: ${error.message}`, true);
      }
    }
    
    async function debugSectionWidths(section) {
      const viewer = document.getElementById('viewer');
      const iframe = viewer.querySelector('iframe');
      const phantomElement = viewer.querySelector('.epub-scroll-phantom');
      
      if (!iframe) {
        log("No iframe found!", true);
        return;
      }
      
      try {
        const doc = iframe.contentDocument;
        const body = doc?.body;
        
        if (!body) {
          log("Cannot access iframe content (CORS?)", true);
          return;
        }
        
        // Get content measurements
        const bodyText = body.textContent || '';
        const contentLength = bodyText.trim().length;
        
        // Get element measurements
        const bodyComputedStyle = window.getComputedStyle ? doc.defaultView.getComputedStyle(body) : body.currentStyle;
        const bodyWidth = body.offsetWidth;
        const bodyScrollWidth = body.scrollWidth;
        const bodyClientWidth = body.clientWidth;
        
        // Get container measurements
        const containerScrollWidth = viewer.scrollWidth;
        const containerOffsetWidth = viewer.offsetWidth;
        const containerScrollLeft = viewer.scrollLeft;
        
        // Get iframe measurements
        const iframeWidth = iframe.offsetWidth;
        const iframeStyle = window.getComputedStyle(iframe);
        
        // Get phantom element info
        const phantomWidth = phantomElement ? phantomElement.offsetWidth : 'No phantom';
        const phantomStyleWidth = phantomElement ? phantomElement.style.width : 'No phantom';
        
        const info = `
          <strong>Content:</strong> ${contentLength} characters<br>
          <strong>Body:</strong> offsetWidth=${bodyWidth}, scrollWidth=${bodyScrollWidth}, clientWidth=${bodyClientWidth}<br>
          <strong>Container:</strong> scrollWidth=${containerScrollWidth}, offsetWidth=${containerOffsetWidth}, scrollLeft=${containerScrollLeft}<br>
          <strong>Iframe:</strong> width=${iframeWidth}, style.width=${iframe.style.width}<br>
          <strong>Phantom:</strong> offsetWidth=${phantomWidth}, style.width=${phantomStyleWidth}<br>
          <strong>Text Sample:</strong> "${bodyText.substring(0, 100)}..."
        `;
        
        // Check for potential issues
        let issues = [];
        
        if (contentLength === 0) {
          issues.push("❌ NO CONTENT - This could be a white page!");
        }
        
        if (bodyScrollWidth > containerScrollWidth) {
          issues.push("⚠️ Body scrollWidth > container scrollWidth - content may be cut off");
        }
        
        if (!phantomElement) {
          issues.push("⚠️ No phantom element found");
        } else if (phantomElement.offsetWidth !== bodyScrollWidth) {
          issues.push(`⚠️ Phantom width (${phantomElement.offsetWidth}) ≠ body scrollWidth (${bodyScrollWidth})`);
        }
        
        if (containerScrollLeft > 0 && containerScrollLeft >= (containerScrollWidth - containerOffsetWidth)) {
          issues.push("⚠️ Scrolled to end - might indicate positioning issue");
        }
        
        const issueText = issues.length > 0 ? `<br><strong>Issues:</strong><br>${issues.join('<br>')}` : '<br>✅ No issues detected';
        
        log(info + issueText, issues.some(i => i.includes('❌')));
        
      } catch (error) {
        log(`Error measuring section: ${error.message}`, true);
      }
    }
  </script>
</body>
</html>
